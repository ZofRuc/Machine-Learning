# -*- coding: utf-8 -*-
"""projket_12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mIKyfrcDVWuvWxRmhvPIEr9y9uN-yOVL
"""

import numpy as np
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Dropout
from keras.utils import np_utils

# Wczytaj dane treningowe i testowe z zestawu danych MNIST
(X_train, y_train), (X_test, y_test) = mnist.load_data()

# Przetwarzanie danych
# Spłaszcz obrazy cyfr do wektorów
num_pixels = X_train.shape[1] * X_train.shape[2]
X_train = X_train.reshape(X_train.shape[0], num_pixels).astype('float32')
X_test = X_test.reshape(X_test.shape[0], num_pixels).astype('float32')
# Normalizuj wartości pikseli do zakresu 0-1
X_train = X_train / 255
X_test = X_test / 255
# Przekształć etykiety klas na postać binarną (one-hot encoding)
y_train = np_utils.to_categorical(y_train)
y_test = np_utils.to_categorical(y_test)
num_classes = y_test.shape[1]

# Zdefiniuj model sieci neuronowej
model = Sequential()
model.add(Dense(512, input_dim=num_pixels, activation='relu'))
model.add(Dropout(0.2))
model.add(Dense(num_classes, activation='softmax'))

# Skompiluj model
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Trenuj model
model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=10, batch_size=200, verbose=2)

# Ocena modelu na zestawie testowym
scores = model.evaluate(X_test, y_test, verbose=0)
print("Dokładność: %.2f%%" % (scores[1] * 100))

model.save('model.h')

import cv2
import numpy as np
from keras.models import load_model
# Wczytaj wytrenowany model
model = load_model('model.h')  # Wymaga wcześniejszego zapisania modelu w pliku 'model.h5'

# Wczytaj plik z odręcznie napisaną cyfrą
image = cv2.imread('5.png', cv2.IMREAD_GRAYSCALE)

# Przetwarzanie pliku z odręcznie napisaną cyfrą
image = cv2.resize(image, (28, 28))  # Dopasuj rozmiar obrazu do 28x28 pikseli
image = image.reshape(1, 784).astype('float32')  # Spłaszcz obraz do wektora
image = image / 255.0  # Normalizuj wartości pikseli do zakresu 0-1

# Rozpoznawanie cyfry za pomocą modelu
predictions = model.predict(image)
predicted_digit = np.argmax(predictions)

print('Rozpoznana cyfra:', predicted_digit)